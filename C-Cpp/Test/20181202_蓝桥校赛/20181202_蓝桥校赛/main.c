/*
 描述
 给定一个1-N的排列A[1], A[2], ... A[N]，定义集合S[K] = {A[K], A[A[K]], A[A[A[K]]] ... }。
 
 显然对于任意的K=1..N，S[K]都是有限集合。
 
 你能求出其中包含整数最多的S[K]的大小吗？
 
 输入
 第一行包含一个整数N。(1 <= N <= 100000)
 
 第二行包含N个两两不同的整数，A[1], A[2], ... A[N]。(1 <= A[i] <= N)
 
 输出
 最大的S[K]的大小。
 
 样例输入
 7
 6 5 1 4 2 7 3
 样例输出
 4
 
 */
//#include <stdio.h>
//int a[100005];
//
//int dfs(int i)
//{
//
//}
//
//int main()
//{
//    int n;
//    int i;
//    scanf("%d", &n);
//    for(i=0; i<n; i++)
//    {
//        scanf("%d", &a[i]);
//    }
//
//
//
//    return 0;
//}


#include <stdio.h>

int main()
{
    int n;
    char a[3];
    double cnt = 0;
    scanf("%d", &n);
    while(n--)
    {
        scanf("%c%c", &a[0], &a[1]);
        if(a[0] == a[1])
        {
            cnt++;
        }
    }
    
    printf("%.2f%%\n", (cnt/n)*100);
    
    return 0;
}






/*
 描述
 小Ho很喜欢在课间去小卖部买零食。然而不幸的是，这个学期他又有在一教的课，而一教的小卖部姐姐以冷若冰霜著称。第一次去一教小卖部买零食的时候，小Ho由于不懂事买了好一大堆东西，被小卖部姐姐给了一个“冷若冰霜”的眼神，食欲都下降了很多。
 
 从那以后，小Ho就学乖了，去小卖部买东西只敢同时买3包以内的零食，并且价格加起来必须是5的整数倍，方便小卖部姐姐算价格。
 
 但是小Ho不擅长计算，所以他把小卖部里所有零食的价格以及他对这个零食的渴望度都告诉了你，希望你能够帮他计算出在不惹恼小卖部姐姐的前提下，能够买到零食的渴望度之和最高是多少？
 
 输入
 每个输入文件包含多组测试数据，在每个输入文件的第一行为一个整数Q，表示测试数据的组数。
 
 每组测试数据的第一行为一个正整数N，表示小卖部中零食的数量。
 
 接下来的N行，每行为一个正实数A和一个正整数B，表示这种零食的价格和小Ho对其的渴望度。
 
 一种零食仅有一包。
 
 对于100%的数据，满足1 <= Q <= 10，1<=N<=50，0<A<=10，1<=B<=100。
 
 对于100%的数据，满足A的小数部分仅可能为0.5或0。
 
 输出
 对于每组测试数据，输出一个整数Ans，表示小Ho可以获得最大的渴望度之和。
 
 样例输入
 1
 4
 0.5 6
 4.5 7
 5.0 4
 2.0 9
 样例输出
 17

 */


//#include <stdio.h>
//#include <math.h>
//
//int main()
//{
//    // 只敢同时买3包以内的零食，并且价格加起来必须是5的整数倍
//    int Q,N;
//    double A[55];
//    int B[55];
//    int i,ans;
//
//    scanf("%d", &Q);
//    while(Q--)
//    {
//        scanf("%d", &N);
//        for(i=0; i<N; i++)
//        {
//            scanf("%lf%d", &A[i], &B[i]);
//        }
//    }
//
//    return 0;
//}




/*
 描述
 小Hi喜欢各种角度。一天，他注意到了钟表上的角度，于是他想考考他的好朋友小Ho：对于一个24小时制的时刻，在 t 秒之后，对应在钟表上时针与分针的夹角是多少。为保证答案的唯一性，只需考虑不超过180°的角。你能帮助小Ho解决这个问题吗？
 
 例如，下图可表示15点30分0秒经过0秒后的时间，其对应的夹角为75°和285°，在这个问题中我们只考虑不超过180°的角，所以此时的夹角为75°。
 
 */

//#include <stdio.h>
//#include <math.h>
//
//int main()
//{
//    int n=0;
//    int h,m,s;
//    int t;
//    int mod = 60*60*12;
//    double h1, m1;
//    double ans;
//    scanf("%d", &n);
//    while(n--)
//    {
//        scanf("%d%d%d", &h, &m, &s);
//        scanf("%d", &t);
//        t = t + (h*60+m)*60+s;
//        t %= mod;
//        h1 = (double)t/(3600*12);
//        m1 = (double)t/3600;
//        m1 = m1 - (int)m1;
//        ans = fabs(h1 - m1) * 360;
//        if(ans > 180)
//            ans = 360 - ans;
//        printf("%.4f\n",ans);
//    }
//
//    return 0;
//}






/*
 问题描述
 
 有n个小朋友围坐成一圈。老师给每个小朋友随机发偶数个糖果，然后进行下面的游戏：
 
 每个小朋友都把自己的糖果分一半给左手边的孩子。
 
 一轮分糖后，拥有奇数颗糖的孩子由老师补给1个糖果，从而变成偶数。
 
 反复进行这个游戏，直到所有小朋友的糖果数都相同为止。
 
 你的任务是预测在已知的初始糖果情形下，老师一共需要补发多少个糖果。
 
 【格式要求】
 
 程序首先读入一个整数N(2<N<100)，表示小朋友的人数。
 接着是一行用空格分开的N个偶数（每个偶数不大于1000，不小于2）
 要求程序输出一个整数，表示老师需要补发的糖果数。
 
 样例输入
 3
 2 2 4
 样例输出：
 4
 */

//#include <stdio.h>
//
//// ok return 1, else return 0;
//int isok(int a[], int n)
//{
//    int i = 0;
//    int tmp = a[0];
//    for(i=0; i<n; i++)
//    {
//        if(tmp != a[i])
//            return 0;
//    }
//    return 1;
//}
//
//int main()
//{
//    int n,i;
//    int count = 0;  // 老师补发糖果数量
//    int a[103] = {0};
//    scanf("%d", &n);
//    for(i=0; i<n; i++)
//    {
//        scanf("%d", &a[i]);
//    }
//
//    while(!(isok(a, n)))
//    {
//        int tmp = a[0];
//        for(i=0; i<n-1; i++)
//        {
//            a[i]=(a[i]+a[i+1])/2;
//        }
//        a[i] = (a[i]+tmp)/2;
//
//        for(i=0; i<n; i++)
//        {
//            if(a[i]%2 != 0)
//            {
//                a[i]++;
//                count++;
//            }
//        }
//    }
//
//
//
//    printf("%d\n", count);
//
//    return 0;
//}






/*
 【问题描述】
 
 任意给定一个正整数N，
 如果是偶数，执行： N / 2
 如果是奇数，执行： N * 3 + 1
 
 生成的新的数字再执行同样的动作，循环往复。
 
 通过观察发现，这个数字会一会儿上升到很高，
 一会儿又降落下来。
 就这样起起落落的，但最终必会落到“1”
 这有点像小冰雹粒子在冰雹云中翻滚增长的样子。
 
 比如N=9
 9,28,14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1
 可以看到，N=9的时候，这个“小冰雹”最高冲到了52这个高度。
 
 输入格式：
 一个正整数N（N<1000000）
 输出格式：
 一个正整数，表示不大于N的数字，经过冰雹数变换过程中，最高冲到了多少。
 
 样例输入：
 10
 样例输出：
 52
 
 样例输入：
 100
 样例输出：
 9232
 */
//#include <stdio.h>
//int main()
//{
//    int n;
//    int final = 0;
//
//    scanf("%d", &n);
//    while(n != 1)
//    {
//        if(n&1)
//        {
//            n = n*3+1;
//        }
//        else
//        {
//            n /= 2;
//        }
////        printf("%d,", n);
//        if(final < n)
//        {
//            final = n;
//        }
//    }
//
//    printf("\n%d\n", final);
//
//    return 0;
//}






//
//int main()
//{
//    int a,b;
//    scanf("%d%d", &a, &b);
//
//    printf("%d", a*b-a-b);
//
//    return 0;
//}
