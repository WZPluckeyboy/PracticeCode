### 操作符

1. 算数操作符

   > `+  -  *  /  %`

   注意点

   + 除了`%`操作符外，其他的几个算数操作符可以用于整数和浮点数，`%`的操作数只能是整数。

   + 对于`/`操作符如果两个操作数都是整数，执行整数除法。只要有一个是浮点数则执行浮点数除法。

2. 移位操作符

   > 左移<<    右移>>

   + 左移规则：左边抛弃，右边补零。

     ```c
     int num = 10;
     num<<1;	//num本身并不发生改变
     num = num<<1;	//num发生改变
     ```

   + 右移规则有两种：

     + 逻辑移位：左边用0填充，右边丢弃。
     + 算数移位：左边用原该值的符号位填充，右边丢弃。

     取决于编译器，常用编译器如VS等用算数右移，算数右移也是比较和逻辑的，如果一个负数按逻辑移位右移，左边用0填充，就会变为正数。

     **对于移位运算，不要移动负数位，这个标准是未定义的，如：**

     ```C
     int num = 10;
     num >> 1;	// error!
     ```

3. 位操作符

   > &：有0为0，全1为1    
   >
   > |：有1为1，全0为0
   >
   > ^：相同为0，相异为1
   >
   > **他们仨的操作数必须是整数！**

   一些题目：

   1）不创建临时变量(第三个变量)，实现两个数的交换。

   2）求一个整数存储在内存中的二进制序列（或求二进制中1的个数）。

4. 赋值操作符

   > **😂不要在if中用`=`，不要连续赋值，如：`a=x=y+1`，可读性下降。**
   >
   > 复合赋值符号会让代码简洁一点。
   >
   > ```C
   > int a = 10;
   > x = x+10;
   > x += 10;
   > ```

5. 单目操作符

   > ！ +  -   
   >
   > &(取地址)  
   >
   > sizeof(以字节为单位)   
   >
   > ~(对于一个数的二进制按位取反)  
   >
   > 前置和后置-- ++   
   >
   > *(解引用)
   >
   > (类型)  强制类型转换

   + sizeof()

     ```C
     int a = 10;
     short s = 1;
     printf("%d\n", sizeof(a));	//OK!
     printf("%d\n", sizeof a);	//OK!
     printf("%d\n", sizeof(int));	//OK!
     printf("%d\n", sizeof int);	//ERROR!
     printf("%d\n", sizeof(s=a+10));	// 2
     printf("%d\n", sizeof(s));		// 2
     ```

     **sizeof是运算符，结果在编译时得到而非运行中获得，sizeof参数可以是任何数据的类型或者数据。**

     sizeof和数组：

     ```C
     #include <stdio.h>
     
     void test1(int arr1[])
     {
     	printf("test1():sizeof(arr1):%d\n", sizeof(arr1));
     }
     
     void test2(char arr2[])
     {
     	printf("test2():sizeof(arr2):%d\n", sizeof(arr2));
     }
     
     int main()
     {
     	int arr1[10] = {0};
     	char arr2[10] = {0};
     	printf("sizeof(arr1):%d\n", sizeof(arr1));
     	printf("sizeof(arr2):%d\n", sizeof(arr2));
     	test1(arr1);
     	test2(arr2);
     	return 0;
     }
     ```

     输出为：

     ```C
     sizeof(arr1):40
     sizeof(arr2):10
     test1():sizeof(arr1):4
     test2():sizeof(arr2):4
     ```

     要注意！数组作为函数参数传进去的只是数组首元素的地址，所以sizeof求出来的是首元素的大小。

   + 对于前置++ -- 和 后置++ --

     > 一定要注意前置和后置的区别，我一次在递归求字符串长度时候，参数为后置++，所以传进去的参数没有变，递归没办法跳出，导致栈溢出，调了半天。😂

     还有一些怪诞的代码：

     ```c
     int i = 2;
     int ret = (++i) + (++i) + (++i);
     printf("%d\n", ret);
     ```

     对于以上代码在Linux环境gcc编译器和vs2013环境下的执行结果是不同的。

     **这段代码的第一个`+`在执行的时候，第三个`++`是否执行是不确定的，也就是执行的顺序不确定，因为依靠操作符的优先级和结合性是无法决定这个的。这段代码并不是一个好的代码，表达式的值依赖于运算符的优先级和结合性，但这两样并不能确定唯一的计算路径。**

6. 关系操作符

   >`>  >=  <  <=  !=  ==`

   注意：不要把`==`写成`=`。

   避免这种错误，可以写成如下：

   ```C
   if(a == 1)
       something();	// 把 == 写成 = 后不容易排查错误
   if(1 == a)		// 写成这样，如果写错了编译器会帮我们找出来～
       something();
   ```

7. 逻辑操作符

   > `&&    ||`

   区分逻辑与、按位与、逻辑或、按位或：

   ```C
   1&2 -> 0
   1&&2 -> 1
   
   1|2 -> 3
   1||2 -> 1
   ```

   + 逻辑与、逻辑或的特点：

     ```C
     /*360笔试题*/
     #include <stdio.h>
     int main()
     {
         int i=0,a=0,b=2,c=3,d=4;
         i = a++ && ++b && d++;
         // i = a++ || ++b || d++;
         printf("a=%d\n b=%d\n c=%d\n d=%d\n", a,b,c,d);
         return 0;
     }
     ```

     这段程序正确输出为：`1 2 3 4`

     如果&&的左边表达式值为假(0)，就不继续算后面的了，后面的都不执行，所以这个题中只有a++了，其他的变量没有改变。

     如果||左边的表达式为真(1)，就不继续算后面的了。

8. 逗号表达式

   > 逗号表达式从左向右依次执行，整个表达式的结果是最后一个表达式的结果。

   如下代码：

   ```C
   /* 1 */
   int a = 1;
   int b = 2;
   int c = (a>b, a=b+10, a, b=a+1);
   // c = 13
   
   /* 2 */
   if(a=b+1, c=a/2, d>0)
       something();
   
   /* 3 */
   a = get_value();
   count_value(a);
   while(a>0)
   {
       //something();
       a = get_value();
       count_value(a);
   }
   // 以上3的代码可改为
   while(a=getvalue(), count_value(a), a>0)
   {
       //something();
   }
   ```

9. 条件操作符

   > exp1?exp2:exp3;

   ```C
   if(a>5)
       b=3;
   else
       b=-3;
   
   a>5?b=3:b=-3;
   b=(a>5?3:-3);
   ```

10. 下标引用、函数调用、结构成员

  > []   ()   .  ->

  []：

  ```C
  int arr[10] = {0};
  arr[1];
  1[arr];
  ```

  ()：

  函数调用操作符，接受一个或者多个操作数，第一个操作数是函数名，剩余的操作数就是传递给函数的参数。

  . ->：这两个就不多说了。

---

## end