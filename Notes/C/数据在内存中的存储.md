# 1. 整型

> 整型：char、short、int、long

## 1.1 存整数

1. 无符号数：原、反、补码一样
2. 有符号数：
   1. 正数：原、反、补码一样
   2. 负数：补码表示

例如：

```c
-10:有符号->负数->存它的补码
以8比特位为例
原： 1000 1010
反： 1111 0101
补： 1111 0110 	->最终存入内存中的-10
```

## 1.2 取整数

看是什么类型(有符号整数 / 无符号整数)

1. 无符号整数：直接取
2. 有符号整数：
   1. 正数：直接取
   2. 负数：补->原再取

例如：

```c
#include <stdio.h>
int main()
{
    char a = -1;
    signed char b = -1;
    unsigned char c = -1;
    printf("a=%d,b=%d,c=%d\n", a, b, c);
    return 0;
}
```

输出：`-1,-1,255`

a和b的结果是一样的，这里就分析下a：

存：a是有符号数负数

```c
a = -1
    原： 1000 0001
    反： 1111 1110
    补： 1111 1111
    1.存的时候不考虑类型，直接存 -1 的补码 1111 1111
    2.在%d输出的时候，会发生整型提升，整型提升默认的是按照变量的原始类型添加前面的比特位，这里的a是有符号的所以前面添加 1，变为 11111111 11111111 11111111 11111111，这样的话用%d输出，结果是 -1。
```

```c
c = -1
    还是一样的，存的时候不考虑类型，存 -1 的补码 1111 1111
    在%d输出的时候，整型提升，添加比特位，这里的c是unsigned类型的，所以前面添加 0，变为：
    00000000 00000000 00000000 11111111
    这样，以%d输出就是255咯。
```

---

# 2. 浮点型

> float、double、long double，浮点数的表示范围在float.h中定义

## 2.1 浮点数在计算机内部的表示方法：

### 浮点数的表示

根据国际标准IEEE 754，任意一个二进制浮点数可以表示为：$(-1)^S * M * 2^E$

+ $(-1)^S$表示符号位，$S=0$时，为正，$S=1$时，为负。

+ M表示有效数字，大于等于1，小于2。

+ $2^E$表示指数位。

栗子：

十进制$5.0$，写成二进制$101.0$，相当于$1.01*2^2$，其中$S=0，M=1.01，E=2$。

十进制$-5.0$，二进制为$-101.0$，相当于$-1.01 * 2^2$，其中$S=1，M=1.01，E=2$。

### 浮点数的存储

对于32位的浮点数(单精度)，最高的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M。

对于64位的浮点数(双精度)，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。

对于有效数字M和指数E，还有一些特别的规定：

+ 有效数字M：

  在计算机内部存储M时，默认这个数的第一位总是1，因此可以被舍去，只保存小数点后面的部分。比如在保存$1.01$的时候，只保存$01$，等到读取的时候，再讲第一位的1加上去。这样，就节省出了1位有效数字。以32位浮点数为例，留给M的只有23位，舍去第一位后，就可以保存24位有效数字。

+ 指数E：

  由内存分配可以看出，E没有符号位，E是一个无符号整数。这意味着，如果E为8位，它的取值范围位$0-255$。如果E位11位，它的取值范围为$0-2047$。但是，在科学计数法中E是可以出现负数的，所以IEEE规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，中间数位127；对于11位的E，中间数是1023。

  比如：$2^{10}$的E是10，保存为32位浮点数时，必须保存成$10+127=137$，即$10001001$。

  + E不全为0或不全为1

    此时指数E的计算值减去127(或1023)，得到真实值，再在有效数字M前加上第一位的1。

    比如：$0.5$的二进制形式为$0.1$，由于规定M的正数部分必须为1，即小数点右移1位，为$1.0*2^{-1}$，其阶码为$-1+127=126$，表示为$01111110$，而尾数$1.0$去掉整数部分为0，补齐0到23位，最终$0.5$的二进制表示为：`0 01111110 00000000000000000000000`。

  + E全为0(浮点数0)

    这时，浮点数的指数E等于$1-127(或1-1023)$即为真实值，有效数字M不再加上第一位的1，而是还原为$0.$xxxxxx的小数。这样做是为了表示$+0 ~ -0$，以及接近于0的很小的数字。

  + E全为1(最小、最大浮点数)

    这时，如果有效数字M全为0，表示$+\infty$和$-\infty$(正负取决于符号位S)。

---

## 2.2 关于浮点数的栗子

```c
int main()
{
    int n = 9;
    // 第一部分
    float *pFloat = (float*)&n;
    printf("n:%d\n", n);
    printf("*pFloat:%f\n", *pFloat);
    
    // 第二部分
    *pFloat = 9.0;
    printf("n:%d\n", n);
    printf("*pFloat:%f\n", *pFloat);
    
    return 0;
}
```

![pic](https://wx2.sinaimg.cn/mw690/006wR0dcly1fx4bfr4hy3j30ew066t94.jpg)



+ 第一部分：

  首先把`0x00000009`(16进制)拆分：符号位S=0，后面8位E=00000000，最后23位M=000 0000 0000 0000 0000 1001。

  9最终表示为浮点数为：`0000 0000 0000 0000 0000 0000 0000 1001`。指数位E全为0，改写成浮点数为：$(-1)^0 * 0.000 0000 0000 0000 0000 0000 0000 1001*2^{-126}=1.001*2^{-146}$。

  显然，这是一个很小的接近于0的正数，所以用十进制小数表示为$0.000000$。

+ 第二部分：

  浮点数9.0表示为二进制：$1001.0$，即$1.001*2^3$。

  M=1.001，E=3+127=130。

  写成二进制：`0 10000010 001 0000 0000 0000 0000 0000`，这个32位的二进制数，表示成十进制正是，1091567616。

---

# EOF

