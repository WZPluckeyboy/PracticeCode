# 函数指针

## 1. 函数指针

函数名代表的是函数地址

```c
int test()
{
    printf("ahoj\n");
    return 0;
}

int main()
{
    printf("test    %p\n", test);
    printf("&test   %p\n", &test);
    test();
    
    return 0;
}
```

输出：

```c
test    0x100000ef0
&test   0x100000ef0
ahoj
```

函数也是有地址滴，要保存函数地址，就要用到函数指针。

```c
void (*pf1)();	// 函数指针，先和*结合，再与()结合。pf1是一个指针，指向一个无参数的函数，返回值为void
void *pf2();	// 返回值为void *的函数
```

到这里才理解了《C陷阱和缺陷》里的那段代码：`(*(void (*)())0)();`

这里的$0$被强制转换为`void(*)()`，函数指针=>解引用，0代表一个函数的地址（地址为0处的函数）

再来看个代码：`void (*signal(int, void(*)(int)))(int);`

这是一段函数声明，函数的返回值为：signal先与*结合=>是个函数指针，指向一个参数为`(int, 函数指针类型)`的一个函数。参数为：int。

对于上面的两行代码，太复杂，需要简化一下：

```c
typedef void(*pfun_t)(int);	// pfun_t是一个函数指针，指向一个参数为int的函数
pfun_t signal(int, pfun_t);	// signal的返回值是个函数指针，参数是int和一个函数指针
```

## 2. 函数指针数组

数组用来存放相同类型数据的，那么把函数的地址存到一个数组中，这个数组就叫做**函数指针数组**。

`int (*parr[10])();`

`parr`先和`[]`结合，说明`parr`是个数组，数组的内容是什么类型呢？是`int (*)()`类型的函数指针。

+ 函数指针数组的用途：**转移表**（例子：计算器）

  普通版：

  ```c
  #include <stdio.h>
  
  int add(int a, int b)
  {
      return a+b;
  }
  int sub(int a, int b)
  {
      return a-b;
  }
  int mul(int a, int b)
  {
      return a*b;
  }
  int diiv(int a, int b)
  {
      return a/b;
  }
  int main()
  {
      int x, y;
      int input = 1;
      int ret = 0;
      while(input)
      {
          printf("=========\n");
          printf("( 1. +  )\n");
          printf("( 2. -  )\n");
          printf("( 3. *  )\n");
          printf("( 4. \\  )\n");
          printf("=========\n");
          printf("choice>");
          scanf("%d", &input);
          switch(input)
          {
              case 1:
                  printf("<(a b)>");
                  scanf("%d%d", &x, &y);
                  ret = add(x, y);
                  break;
              case 2:
                  printf("<(a b)>");
                  scanf("%d%d", &x, &y);
                  ret = sub(x, y);
              case 3:
                  printf("<(a b)>");
                  scanf("%d%d", &x, &y);
                  ret = mul(x, y);
              case 4:
                  printf("<(a b)>");
                  scanf("%d%d", &x, &y);
                  ret = diiv(x, y);
              default:
                  printf("error!\n");
                  break;
          }
          printf("ret = %d\n", ret);
      }
      
      return 0;
  }
  ```

  函数指针数组实现：

  ```c
  int main()
  {
      int x, y;
      int input = 1;
      int ret = 0;
      int (*p[5])(int x, int y) = {0, add, sub, mul, diiv};   // 转移表
      while(input)
      {
          printf("=========\n");
          printf("( 1. +  )\n");
          printf("( 2. -  )\n");
          printf("( 3. *  )\n");
          printf("( 4. \\  )\n");
          printf("=========\n");
          printf("choice>");
          scanf("%d", &input);
          if((input<=4 && input>=1))
          {
              printf("a b >");
              scanf("%d%d", &x, &y);
              ret = (*p[input])(x,y);
          }
          else
          {
              printf("error!");
          }
          printf("ret = %d\n", ret);
      }
      
      return 0;
  }
  ```


## 3. 指向函数指针数组的指针

上面这个东西，首先是个指针，指向一个数组，数组的元素是函数指针。

```c
void test(const char *str)
{
    printf("%s\n", str);
}

int main()
{
    // 函数指针pf
    void (*pf)(const char *) = test;
    
    // 函数指针的数组pfarr
    void (*pfarr[5])(const char *str);
    pfarr[0] = test;
    
    // 指向函数指针数组pfarr的指针ppfarr
    void (*(*ppfarr)[10])(const char *) = &pfarr;
    
    return 0;
}
```

