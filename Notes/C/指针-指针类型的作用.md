### 指针类型

### 1. 指针类型的大小

> 在32位机器上，地址是32个0或1组成的二进制序列，如果每个比特位都给一个地址位，则32为机能编址的范围只为512MB，若以4字节编址，32位机则可以编址4GB。
>
> 在64位机器上，有64根地址线，则一个指针变量的大小是8字节。

对于以下代码：

```
int main(int argc, const char * argv[])
{
    printf("char* : %lu\n",sizeof(char*));
    printf("short* : %lu\n",sizeof(short*));
    printf("int* : %lu\n",sizeof(int*));
    printf("float* : %lu\n",sizeof(float*));
    printf("double* : %lu\n",sizeof(double*));
    printf("long double* : %lu\n",sizeof(long double*));
    return 0;
}
```

- 在**64位**机下的输出为：

[![-64](https://camo.githubusercontent.com/98b19b496e93806971e221b986c1327fd609b9cc/68747470733a2f2f7778312e73696e61696d672e636e2f6d773639302f30303677523064636c793166776576763836786a666a333069753039303734792e6a7067)](https://camo.githubusercontent.com/98b19b496e93806971e221b986c1327fd609b9cc/68747470733a2f2f7778312e73696e61696d672e636e2f6d773639302f30303677523064636c793166776576763836786a666a333069753039303734792e6a7067)

- 在**32位**机下的输出为：

[![gcc main.c -m32](https://camo.githubusercontent.com/9196131c1403410461d37d3836786465697e69ca/68747470733a2f2f7778332e73696e61696d672e636e2f6d773639302f30303677523064636c7931667765767631327078746a33316b77306a71646f6f2e6a7067)](https://camo.githubusercontent.com/9196131c1403410461d37d3836786465697e69ca/68747470733a2f2f7778332e73696e61696d672e636e2f6d773639302f30303677523064636c7931667765767631327078746a33316b77306a71646f6f2e6a7067)

**问题来了：**

> 为什么不同类型的指针大小都是一样的呢？为什么要这么设计？

### 2. 指针类型的作用

- 指针类型决定了对指针解引用的时候有多大的权限（能操作几个字节）。比如：`char*`的指针解引用只能访问一个字节，而`int*`的指针解引用就能访问四个字节。

看下面的这段代码：

```
int main(int argc, const char * argv[])
{
    int i = 0x11223344;
    int *pi = &i;
    *pi = 0;
    
    int c = 0x11223344;
    char *pc = &c;
    *pc = 0;
    
    return 0;
}
```

Debug看内存变化：

[![p](https://camo.githubusercontent.com/fa302cfc6e28d6ee72a86a23d8f8e9cbd10d451e/68747470733a2f2f7778332e73696e61696d672e636e2f6d773639302f30303677523064636c7931667765776c32706c77726a33306c303037343734722e6a7067)](https://camo.githubusercontent.com/fa302cfc6e28d6ee72a86a23d8f8e9cbd10d451e/68747470733a2f2f7778332e73696e61696d672e636e2f6d773639302f30303677523064636c7931667765776c32706c77726a33306c303037343734722e6a7067)

[![img](https://camo.githubusercontent.com/57a12eddf6d4ca658d9fd2bc6ede68ce474a3b0d/68747470733a2f2f7778322e73696e61696d672e636e2f6d773639302f30303677523064636c7931667765776c6c6d666e336a3330626f30366d3379762e6a7067)](https://camo.githubusercontent.com/57a12eddf6d4ca658d9fd2bc6ede68ce474a3b0d/68747470733a2f2f7778322e73696e61696d672e636e2f6d773639302f30303677523064636c7931667765776c6c6d666e336a3330626f30366d3379762e6a7067)

发现：

`i=0x11223344`在执行`*pi=0;`后全部变为了0

`c=0x11223344`在执行`*pc=0;`后只有高位变成了0

说明：int*类型的指针解引用后，操作权限是4个字节(int的大小)。

char*解引用后，操作权限仅为一个字节。

验证了：指针类型决定了对指针解引用的时候有多大的权限（能操作几个字节）。

**问题又来了：**

为什么高位的44变为0了呢？

这和数据在内存中存储的模式有关。[大小端模式](https://baike.baidu.com/item/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F/6750542?fr=aladdin)

> 大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。
>
> 小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

- 指针类型决定了指针指向前或者向后一步有多大距离。

对于以下代码：

```
int main(int argc, const char * argv[])
{
    int n = 10;
    int *pi = &n;
    char *pc = (char*)&n;
    
    printf("&n : %p\n", &n);
    printf("pi : %p\n", pi);
    printf("pi+1 : %p\n", pi+1);
    printf("-----------------------\n");
    printf("pc : %p\n", pc);
    printf("pc+1 : %p\n", pc+1);
    
    return 0;
}
```

有在64位机下有如下输出：

[![pic](https://camo.githubusercontent.com/a923b880ac9b3ed9eba1143f3e79703fe214c301/68747470733a2f2f7778342e73696e61696d672e636e2f6d773639302f30303677523064636c793166776578346f373074356a3330696d3038737766642e6a7067)](https://camo.githubusercontent.com/a923b880ac9b3ed9eba1143f3e79703fe214c301/68747470733a2f2f7778342e73696e61696d672e636e2f6d773639302f30303677523064636c793166776578346f373074356a3330696d3038737766642e6a7067)

可以看到：

```
pi=pc=&n
```

但是：

`pi+1` 和 `pc+1` 不同

`pi+1 - pi` = 8

`pc+1 - pc` = 1

验证了：指针类型决定了指针指向前或者向后一步有多大距离。

------

## 完