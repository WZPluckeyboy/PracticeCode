# 字符串函数

## 1. strlen()

`size_t strlen(const char *s);`

+ 以`\0`作为结束标志，这个函数返回的是字符串中第一个`\0`前面的字符个数，不包括`\0`。
+ 函数的返回值是`size_t`，是一个无符号的数。

```c
#include <stdio.h>
#include <string.h>

int main(int argc, const char * argv[])
{
    const char * s1 = "abcdef";
    const char * s2 = "ab";
    if(strlen(s2) - strlen(s1) > 0)	// 无符号数 - 无符号数 = 无符号数
    {
        printf("s1 < s2\n");	// 输出这句！
    }
    else
    {
        printf("s1 > s2\n");
    }
    
    return 0;
}
```

## 2. strcpy()

`char * stpcpy(char * dst, const char * src);`

+ 函数的返回值是拷贝后的`dst`的地址。

+ 源字符串必须以`\0`结束。

+ 会将源字符串中的`\0`拷贝到目标空间。

+ 目标空间必须足够大，足以容纳源字符串。

+ 目标空间必须可以改变！

  ## strncpy()

  `char * strncpy(char * dst, const char * src, size_t len);`

  + 拷贝len个字符串从源字符串到目标字符串
  + 如果源字符串的长度小于len，拷贝完源字符串之后，在目标后面继续追加0，直到len个。

  ![strncpy](https://wx3.sinaimg.cn/mw690/006wR0dcly1fxoyvwya4wj314i0u0wi3.jpg)

## 3. strcat()

`char * strcat(char *restrict s1, const char *restrict s2);`

+ 源字符串必须以`\0`结束。

+ 目标空间必须足够大，足以容纳源字符串。

+ 目标空间必须可以改变！

+ **字符串自己给自己拼接，会把`\0`覆盖掉（因为拼接过程是一个字符一个字符的copy）。**

  ## strncat()

  `char * strncat(char *restrict s1, const char *restrict s2, size_t n);`

  + 从s2中拷贝n个字符串到s1字符串的后面，如果s2字符串的长度小于n，只拷贝到`\0`为止。

  ![strncat](https://wx2.sinaimg.cn/mw690/006wR0dcly1fxoz0lmbpzj314e0u0gpy.jpg)

## 4. strcmp()

`int strcmp(const char *s1, const char *s2);`

注意！这个函数比较的是对应位置的ascii码的大小，而不是比较长度。

+ `s1 > s2`，返回大于0的数。

+ `s1 == s2`，返回0。

+ `s1 < s2`，返回小于0的数。

  ## strncmp()

  `int strncmp(const char *s1, const char *s2, size_t n);`

  + 比较到出现第一个字符不一样的地方或一个字符串结束或者n个字符全部比完。

  栗子：查找以`R2`开头的字符串。

  ```c
  int main()
  {
      char str[][5] = { "R2D2", "C3PO", "R2A6" };
      for(int n=0; n<3; n++)
      {
          if(strncmp(str[n], "R2xx", 2) == 0)
          {
              printf("%s\n", str[n]);
          }
      }
      
      return 0;
  }
  ```

## 5. strstr()

`char * strstr(const char *haystack, const char *needle);`

+ 查找第二个字符串参数在第一个参数重首次出现的地方，返回指向这个地方的指针。

栗子：

```c
int main()
{
    char str[] = "This is a simple string!";
    char * p = NULL;
    p = strstr(str, "simple");
    printf("%s\n", p);
    strncpy(p, "aaaaaa", 6);
    puts(p);
    
    return 0;
}
```



## 6. strtok()

`char * strtok(char *restrict str, const char *restrict sep);`

**打散字符串！**

+ 第一个参数str是要打散的字符串，第二个参数是个字符串，定义了用作分隔符的字符集合。

+ 第一个参数必须是可以修改的。打散的过程其实就是将str中出现sep的地方替换为`\0`，对于str中连续出现的分隔符，只会将第一个分隔符替换为`\0`，其他的跳过。

  例如：str = `str:::str:end`，sep = `:`。

+ `strtok`函数的第一个参数不为`NULL`，函数将找到`str`中第一个标记，`strtok`函数将保存它在字符串中的位置。
+ `strtok`函数的第一个参数为`NULL`，函数将在同一个字符串中被保存的位置开始，查找下一个标记。
+ 如果字符串中不存在更多的标记，返回`NULL`指针。

栗子1：

```c
#include <stdio.h>
#include <string.h>

int main()
{
    char str[100] = "abcdefg@qq.com";
    char *e = "@.";
    char *p = NULL;
    p = strtok(str, e);
    
    while(p != NULL)
    {
        puts(p);
        p = strtok(NULL, e);
    }
    
    return 0;
}
```

栗子2：

```c
int main()
{
    char str[100] = "str::::str...end";
    char *e = ":.";
    char *p = strtok(str, e);
    while(p != NULL)
    {
        puts(p);
        p = strtok(NULL, e);
    }
    
    return 0;
}
```

![strtok](https://wx4.sinaimg.cn/mw690/006wR0dcly1fxp0450dcuj30zt0u0n3a.jpg)

可以看到，当出现连续的分隔符时候，只会把第一个分隔符替换为`\0`，跳过后面的分隔符，返回的值是遇到的第一个不是分隔符的地址。

## 7. strerror()

`char * strerror(int errnum);`

+ 返回错误码，对应的错误信息。

栗子：输出结果：**No such file or directory**

```c
#include <stdio.h>
#include <string.h>
#include <errno.h>

int main()
{
    FILE *fp = fopen("test.txt", "r");
    if(fp == NULL)
    {
        printf("%s\n", strerror(errno));
    }
    
    return 0;
}
```

在C库中，`errno.h`是一个全局的错误码，成功为0，不成功为非0。非0表示失败，还有为什么失败的字符串描述。

main函数的返回值称为程序的退出码，在Linux下使用：`echo $?`命令可以查看最近一次程序执行完成的退出码。

![echo $?](https://wx2.sinaimg.cn/mw690/006wR0dcly1fxp159wyw3j30xc09k768.jpg)