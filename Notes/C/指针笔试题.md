# 指针笔试题

+ 题1

```c
int main(int argc, const char * argv[])
{
    int a[5] = {1,2,3,4,5};
    int *p = (int *)(&a+1); // p指向5后面的那个地址
    printf("%d,%d\n", *(a+1), *(p-1));  //2,5
    
    return 0;
}
```

+ 题2

```c
struct test
{
    int Num;
    char *pcName;
    shortsDate;
    char cha[2];
    shortsBa[4];
}*p;
假设结构体test的大小为20个字节，p的地址为0x100000。
p + 0x1 = ?	// p+1 => +20
(unsigned long)p + 0x1 = ?	// 0x100001 (eg: int a = 0, a + 1 = 1)
(unsigned int *)p + 0x1 = ?	// 0x100004 (加一个指针的大小，32位平台下4)
```

+ 题3

```c
int main()
{
    int a[4] = {1,2,3,4};
    int *p1 = (int *)(&a+1);
    int *p2 = (int *)((int)a+1);
    printf("%x,%x\n", p1[-1], *p2);
    // p1[-1] 输出 4
    // *p2 这个编译可以通过，但是运行错误
    return 0;
}
```

在内存中：

![指针笔试题3](https://wx4.sinaimg.cn/mw690/006wR0dcly1fxnh37huqmj31o60u0abh.jpg)

+ 题4

```c
int main()
{
    int a[3][2] = { (0,1), (2,3), (4,5) };
    int *p = a[0];
    printf("%d\n", p[0]); // 输出1
    
    return 0;
}
```

注意逗号表达式：运算结果为后面的值

所以：

![4](https://wx3.sinaimg.cn/mw690/006wR0dcly1fxnhbmau9fj30fi0fuq3k.jpg)

+ 题5

```c
int main()
{
    int a[5][5];
    int (*p)[4];//注意这里！
    p = a;
    printf("%p,%d\n", &p[4][2]-&a[4][2], &p[4][2]-&a[4][2]); //输出： -4的补码，-4
    
    return 0;
}
```

![5](https://wx1.sinaimg.cn/mw690/006wR0dcly1fxnhvji5v2j31nw0poq6g.jpg)

输出他们之间元素的个数。

因为`p[4][2]`的地址小于`a[4][2]`的地址，所以为`-4`，但是由于输出的时候，`%p`输出的是地址，也就是一个无符号的数，所以将`-4`的补码输出，`%d`正常输出。

+ 题6

```c
int main()
{
    int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
    int *p1 = (int *)(&aa + 1);
    int *p2 = (int *)(*(aa + 1));
    printf("%d,%d\n", *(p1-1), *(p2-1));	// 输出10，5
    
    return 0;
}
```

`&aa+1`跨过了整个数组`aa`的长度，指向元素10后的地址。

`aa+1`代表的跨过了一个`aa`的元素，而`aa`是一个二维数组，它的元素是一个一维数组。

如图：

![6](https://wx3.sinaimg.cn/mw690/006wR0dcly1fxnigcsmz0j30oy0fiaaw.jpg)

+ 题7

```c
int main()
{
    char *a[] = {"work", "at", "360"};
    char **pa = a;
    pa++;
    printf("%s\n", *pa);	// 输出at
    
    return 0;
}
```

![7](https://wx4.sinaimg.cn/mw690/006wR0dcly1fxnipjqiicj31460c475c.jpg)

+ 题8

```c
int main()
{
    char *c[] = { "ENTER", "NEW", "POINT", "FIRST" };
    int **cp[] = { c+3, c+2, c+1, c };
    char ***cpp = cp;
    printf("%s\n", **++cpp);		// POINT
    printf("%s\n", *--*++cpp+3);	// ER
    printf("%s\n", *cpp[-2]+3);		// ST
    printf("%s\n", cpp[-1][-1]+1);	// EW
    
    return 0;
}
```

`++、—`的优先级高于`*`，`*`的优先级高于`+`。

`++cpp`会影响`cpp`的值，但`cpp+1`不会影响。

`[]`的优先级大于`*`。

![8.1](https://wx2.sinaimg.cn/mw690/006wR0dcly1fxnj61eghkj31fy0l0q5n.jpg)

`**++cpp`：先`++`，此时的`cpp`指向`cp[1]`，解引用为`c[2]`，再解引用即为`POINT`。

![8.2](https://wx2.sinaimg.cn/mw690/006wR0dcly1fxnjdh5q1zj31fq0k00ve.jpg)

`*--*++cpp+3`：经过上一步，`cpp`现在的指向如上图。

先`++`，此时`cpp`指向`cp[2]`，解引用即为`cp[2]`，再`--`，此时改变了`cp[2]`的指向，他指向`c[0]`，再解引用即为`c[0]`，给`c[0]+3`，输出的结果为`ER`。

![8.3](https://wx2.sinaimg.cn/mw690/006wR0dcly1fxnjlyh6yzj31jm0hy0vf.jpg)

`*cpp[-2]+3`：经过上一步，现在的指向如上图所示。

`cpp[-2]`指向了`cp[0]`，解引用指向`c[3]`，`c[3]+3`输出`ST`。



`cpp[-1][-1]+1`：经过上一步并没有改变指针的指向。

`cpp[-1][-1]`代表`c[1]`，再`+1`输出`EW`。