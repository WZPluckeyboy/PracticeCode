### 指针类型

### 1. 指针类型的大小

> 在32位机器上，地址是32个0或1组成的二进制序列，如果每个比特位都给一个地址位，则32为机能编址的范围只为512MB，若以4字节编址，32位机则可以编址4GB。
>
> 在64位机器上，有64根地址线，则一个指针变量的大小是8字节。

对于以下代码：

```C
int main(int argc, const char * argv[])
{
    printf("char* : %lu\n",sizeof(char*));
    printf("short* : %lu\n",sizeof(short*));
    printf("int* : %lu\n",sizeof(int*));
    printf("float* : %lu\n",sizeof(float*));
    printf("double* : %lu\n",sizeof(double*));
    printf("long double* : %lu\n",sizeof(long double*));
    return 0;
}
```

+ 在**64位**机下的输出为：

![-64](https://wx1.sinaimg.cn/mw690/006wR0dcly1fwevv86xjfj30iu09074y.jpg)

+ 在**32位**机下的输出为：

![gcc main.c -m32](https://wx3.sinaimg.cn/mw690/006wR0dcly1fwevv12pxtj31kw0jqdoo.jpg)

**问题来了：**

> 为什么不同类型的指针大小都是一样的呢？为什么要这么设计？

### 2. 指针类型的作用

+ 指针类型决定了对指针解引用的时候有多大的权限（能操作几个字节）。比如：`char*`的指针解引用只能访问一个字节，而`int*`的指针解引用就能访问四个字节。

看下面的这段代码：

```C
int main(int argc, const char * argv[])
{
    int i = 0x11223344;
    int *pi = &i;
    *pi = 0;
    
    int c = 0x11223344;
    char *pc = &c;
    *pc = 0;
    
    return 0;
}
```

Debug看内存变化：

![p](https://wx3.sinaimg.cn/mw690/006wR0dcly1fwewl2plwrj30l007474r.jpg)

![](https://wx2.sinaimg.cn/mw690/006wR0dcly1fwewllmfn3j30bo06m3yv.jpg)

发现：

`i=0x11223344`在执行`*pi=0;`后全部变为了0

`c=0x11223344`在执行`*pc=0;`后只有高位变成了0

说明：int*类型的指针解引用后，操作权限是4个字节(int的大小)。

char*解引用后，操作权限仅为一个字节。

验证了：指针类型决定了对指针解引用的时候有多大的权限（能操作几个字节）。

**问题又来了：**

为什么高位的44变为0了呢？

这和数据在内存中存储的模式有关。[大小端模式](https://baike.baidu.com/item/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F/6750542?fr=aladdin)

> 大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。
>
> 小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

+ 指针类型决定了指针指向前或者向后一步有多大距离。

对于以下代码：

```C
int main(int argc, const char * argv[])
{
    int n = 10;
    int *pi = &n;
    char *pc = (char*)&n;
    
    printf("&n : %p\n", &n);
    printf("pi : %p\n", pi);
    printf("pi+1 : %p\n", pi+1);
    printf("-----------------------\n");
    printf("pc : %p\n", pc);
    printf("pc+1 : %p\n", pc+1);
    
    return 0;
}
```

有在64位机下有如下输出：

![pic](https://wx4.sinaimg.cn/mw690/006wR0dcly1fwex4o70t5j30im08swfd.jpg)

可以看到：

`pi=pc=&n`

但是：

`pi+1` 和 `pc+1` 不同

`pi+1 - pi` = 8

`pc+1 - pc` = 1

验证了：指针类型决定了指针指向前或者向后一步有多大距离。

----

## 完